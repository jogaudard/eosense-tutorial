{
  "hash": "6d68ebd80a252952d5bbb0e087822cdd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Full tutorial\"\n---\n\n\n\n\n\n\n# Importing the data\n\nIn this section we will use the data in the ex_data folder.\nMore ressources on data import are available in [this vignette](https://plant-functional-trait-course.github.io/fluxible/articles/data-prep.html) on the fluxible website.\n\n\n## Importing log file\n\nImporting the log and turning it into a dataframe with chamber ID (port nb), chamber closing time and re-opening time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# building col names\nchamber_colnames <- c(\n    \"port\", \"valvestatus\", \"chamberstatus\",\n    \"aux1\", \"aux2\", \"aux3\", \"aux4\", \"aux5\",\n    \"temperaturev\", \"pressure\"\n    )\nlog_colnames <- c(\n    \"epochtime\",\n    rep(chamber_colnames, times = 12)\n)\n\nchamber_log_read <- list.files(\n    \"ex_log\",\n    full.names = TRUE\n) |>\n    map_dfr(\n        read_log,\n        col_names = log_colnames\n    )\n# read_log(\"ex_log/FRMonitor_0012.log\", col_names = log_colnames)\n# repeated colnames are normal\nchamber_log_all <- chamber_log_read |>\n    pivot_longer(!c(epochtime), names_to = c(\".value\", \"variable\"), names_sep = \"_\") |>\n    filter(\n        port %in% c(1:12) # we filter out all the rows with port -1\n    ) |>\n    arrange(epochtime) |> # just to be sure\n    mutate( # without grouping\n        chamber = case_when(\n            chamberstatus %in% c(1:3) ~ \"open\",\n            chamberstatus == 0 ~ \"closed\"\n        ),\n        change_id = consecutive_id(port, chamberstatus), #detecting if same port but new measurement\n        datetime = as_datetime(epochtime) # we work in datetime\n    ) |>\n    filter(\n        # chamberstatus %in% c(1:3) # very conservative, we can adjust the focus window later in flux_fitting\n        chamberstatus == 1\n        # valvestatus == 10\n    ) |>\n    mutate(\n        measurement_id = consecutive_id(change_id) # just getting rid of the missing id after filter\n        )\n    \nchamber_log <- chamber_log_all |>\n    mutate(\n        .by = c(measurement_id),\n        closing = min(datetime) - 300, # can be recut in flux_fitting, but so we see better\n        opening = max(datetime) + 300\n    ) |>\n    select(measurement_id, port, closing, opening) |>\n    distinct()\n\n# We make a separate df for temp and pressure so we keep the 4 seconds reads\nchamber_temp_pres <- chamber_log_all |>\n    mutate(\n        air_temp = temperaturev * 15, # need to ask the exact conversion factor, for now this one makes sense\n        pressure = pressure / 101.325 # need atm for fluxible\n    ) |>\n    select(datetime, air_temp, pressure)\n\n# View(chamber_log_all)\n```\n:::\n\n\n\n\nPossible improvements\n\n- take into account the chamber status better and  use it to by-pass the start and end cuts in flux_fitting. Opening and closing status would be \"cut\" (not used for fitting but visible on the plot), and fully open would be \"keep\".\n- keep the other columns\n- Because of the inconsistant offset between the closing of the chamber and the start of the flux, it is difficult to make a proper record of start/end of fluxes.\n\n## Importing data file\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_read <- list.files(\n    \"ex_data\",\n    full.names = TRUE\n) |>\n    map_dfr(\n        read_table\n    )\n# read_table(\"ex_data/JFAADS2294-20241211-193921-DataLog_User.dat\")\n\ndata <- data_read |>\n    mutate(\n        f_datetime = as_datetime(paste(DATE, TIME))\n    ) |>\n    left_join(chamber_temp_pres, by = join_by(f_datetime == datetime)) |> # adding air temp and pressure here\n    select(f_datetime, CO2_dry, air_temp, pressure) # we keep it simple for now and work only on CO2\n\n# View(data)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n# Processing the data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fluxible)\n\nconc <- flux_match(\n    raw_conc = data,\n    field_record = chamber_log,\n    f_datetime = f_datetime,\n    start_col = closing,\n    end_col = opening,\n    fixed_length = FALSE,\n    time_diff = -15000 # 4h10\n) |>\n    drop_na(CO2_dry)\n# View(conc)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nconc_fit <- flux_fitting(\n    conc_df = conc,\n    f_conc = CO2_dry,\n    fit_type = \"linear\",\n    # fit_type = \"exp_zhao18\",\n    start_cut = 300,\n    end_cut = 300\n)\n#> Warning in flux_fitting(conc_df = conc, f_conc = CO2_dry, fit_type = \"linear\", : \n#>  fluxID 45 : slope was estimated on 216 points out of 857 seconds\n#>  fluxID 53 : slope was estimated on 851 points out of 861 seconds\n#>  fluxID 66 : slope was estimated on 852 points out of 853 seconds\n#>  fluxID 69 : slope was estimated on 172 points out of 853 seconds\n#>  fluxID 70 : slope was estimated on 849 points out of 856 seconds\n#>  fluxID 71 : slope was estimated on 851 points out of 857 seconds\n#>  fluxID 72 : slope was estimated on 845 points out of 853 seconds\n#>  fluxID 87 : slope was estimated on 859 points out of 860 seconds\n#>  fluxID 89 : slope was estimated on 848 points out of 849 seconds\n# View(conc_fit)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nconc_flags <- flux_quality(\n    slopes_df = conc_fit,\n    f_conc = CO2_dry,\n    force_discard = 72 # obviously a complete mismatch\n)\n#> \n#>  Total number of measurements: 55\n#> \n#>  ok \t 30 \t 55 %\n#>  discard \t 21 \t 38 %\n#>  zero \t 3 \t 5 %\n#>  force_discard \t 1 \t 2 %\n#>  start_error \t 0 \t 0 %\n#>  no_data \t 0 \t 0 %\n#>  force_ok \t 0 \t 0 %\n#>  force_zero \t 0 \t 0 %\n#>  force_lm \t 0 \t 0 %\n#>  no_slope \t 0 \t 0 %\n# View(conc_flags)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflux_plot(\n    conc_flags,\n    f_conc = CO2_dry,\n    print_plot = FALSE,\n    output = \"pdfpages\",\n    scale_x_datetime_args = list(\n        date_breaks = \"10 min\",\n        minor_breaks = \"2 min\",\n        date_label = \"%e/%m \\n %H:%M\"\n    ),\n    f_plotname = \"eosense4h10f\",\n    f_ylim_upper = 650\n    )\n\n```\n:::\n\n\n\n\nNote: I found a bug in flux_calc, it is not dealing well with the pressure as a variable.\nIt is fixed in fluxible v1.2.5 (dev version), if you are using the CRAN version (v1.2.2) you will need to set the pressure as a constant.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfluxible_df <- flux_calc(\n    slopes_df = conc_flags,\n    slope_col = f_slope_corr,\n    temp_air_col = air_temp,\n    setup_volume = 72, # not sure if correct, found on website\n    # setup_volume = 4.756,\n    plot_area = 0.21, # to check\n    # plot_area = 0.032,\n    # atm_pressure = 1,\n    atm_pressure = pressure,\n    conc_unit = \"ppm\",\n    flux_unit = \"umol/m2/s\",\n    cols_keep = \"f_quality_flag\"\n) |>\n    rename(\n        fluxible_flux = \"f_flux\",\n        fluxible_slope = \"f_slope_corr\"\n    ) |>\n    mutate(\n        f_datetime = f_datetime + 29329 # correcting the other way to match eosense\n    )\n#> Cutting data according to 'keep_arg'...\n#> Averaging air temperature for each flux...\n#> Creating a df with the columns from 'cols_keep' argument...\n#> Calculating fluxes...\n#> R constant set to 0.082057\n#> Concentration was measured in ppm\n#> Fluxes are in umol/m2/s\n# View(fluxible_df)\n\nsaveRDS(fluxible_df, \"compare_data/fluxible_df.rds\")\n```\n:::\n\n\n\n\nStructure of fluxible_df:\n\n\n\n::: {.cell}\n\n```\n#> tibble [55 Ã— 8] (S3: tbl_df/tbl/data.frame)\n#>  $ f_quality_flag    : chr [1:55] \"discard\" \"ok\" \"ok\" \"ok\" ...\n#>  $ f_fluxid          : Factor w/ 113 levels \"1\",\"2\",\"3\",\"4\",..: 45 4..\n#>  $ fluxible_slope    : num [1:55] NA 0.023 0.0543 0.0564 0.0222 ...\n#>  $ f_temp_air_ave    : num [1:55] 10.7 NaN 10.7 10.9 11 ...\n#>  $ f_atm_pressure_ave: num [1:55] 0.993 NaN 1.048 0.992 1.052 ...\n#>  $ f_datetime        : POSIXct[1:55], format: \"2024-12-11 20:37:33\" ..\n#>  $ fluxible_flux     : num [1:55] NA NaN 0.838 0.822 0.343 ...\n#>  $ f_model           : chr [1:55] \"linear\" \"linear\" \"linear\" \"linea\"..\n#>  - attr(*, \"fit_type\")= chr \"linear\"\n```\n:::\n",
    "supporting": [
      "tutorial_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}